--@name midi player
--@author
--@client
--@include midi_parser.txt

require("midi_parser.txt")

--local download = "http://www.theparticle.com/files/library/audio/doom/d_e1m1.mid" -- doom theme (sounds like ass)
--local download = "https://upload.wikimedia.org/wikipedia/commons/5/55/MIDI_sample.mid"
--local download = "https://bitmidi.com/uploads/85263.mid" -- pirates of the carribean (works kinda ok)
--local download = "https://bitmidi.com/uploads/105034.mid" -- toto africa
--local download = "https://bitmidi.com/uploads/91361.mid" -- darude (works well)
--local download = "https://bitmidi.com/uploads/72257.mid" -- mario theme (works alright)
--local download = "https://bitmidi.com/uploads/87390.mid" -- rickroll (eeeh)
--local download = "https://bitmidi.com/uploads/4280.mid" -- Age of empires 2 title theme (sounds like ass)
--local download = "https://bitmidi.com/uploads/68140.mid" -- zelda overworld theme
--local download = "https://bitmidi.com/uploads/101128.mid" -- dragonborn theme (awesome)
--local download = "https://bitmidi.com/uploads/75622.mid" -- mortal kombat (sounds ehh, wrong instrument)
--local download = "https://bitmidi.com/uploads/112953.mid" -- ganon's theme (sounds shit)
--local download = "https://bitmidi.com/uploads/101518.mid" -- dragon roost island (sounds shit, might need implementation of key velocity to fix)
--local download = "https://bitmidi.com/uploads/101561.mid" -- hyrule field twilight princess (sounds great)

local download = "https://red.extra.tools/beach.mid" -- meme
--local download = "https://red.extra.tools/heart.mid" -- titanic theme
--local download = "https://bitmidi.com/uploads/85738.mid" -- pokemon elite four
--local download = "https://bitmidi.com/uploads/85754.mid" -- pokemon center

--local download = "https://bitmidi.com/uploads/110325.mid" -- mii channel
--local download = "https://bitmidi.com/uploads/100444.mid" -- tetris

--local forced_instrument = "sound/synth/tri.wav"

local function doParse(str,callback)
    print("PARSING MIDI FILE")
    local co = coroutine.create( parseMIDI )
    coroutine.resume( co, str, forced_instrument )
    
    local function checkQ(n)
        return quotaAverage() < quotaMax()*n
    end
    
    hook.add("think","parseMIDI",function()
        local iter = 0
        while checkQ(0.95) do
            iter = iter + 1
            if iter > 20 then break end
            local status, errmsg = coroutine.resume( co )
            
            if status == false then
                hook.remove( "think", "parseMIDI" )
                error(errmsg)
                return
            end
            
            if coroutine.status( co ) == "dead" then
                print("DONE PARSING!")
                hook.remove( "think", "parseMIDI" )
                callback( status )
                return
            end
        end
    end)
end

local function playMIDI(parsed)
    local format = parsed.format
    
    -- pre-load all instruments we need
    -- this immediately destroys them again after because we
    -- only want to cache the sound files so they can be loaded 
    -- instantly as necessary later
    local wait = 0
    local num_instruments = 0
    for _,_ in pairs( parsed.instruments ) do num_instruments = num_instruments + 1 end
    
    if bass.soundsLeft() < num_instruments then error("Too many different instruments for current starfall bass limits") end
    
    local num_per_channel = math.floor(bass.soundsLeft() / num_instruments)
    print("Creating",num_per_channel,"sound channels per sound")
    local sound_channels = {}
    
    local channel_pitches = {}
    local available_instruments = {}
    local instrument_status = {}
    local function addAvailableSound(path,snd)
        if not available_instruments[path] then available_instruments[path] = {} end
        available_instruments[path][ #available_instruments[path]+1 ] = snd
        
        local length = snd:getLength()
        local isLooped = false
        if string.find( path, "/synth/" ) ~= nil then
            snd:setLooping(true)
            length = 9001
            isLooped = true
        end
        
        instrument_status[snd] = {
            isPlaying = false,
            soundDuration = length,
            finishPlaying = 0,
            isLooped = isLooped
        }
    end
    
    local function getAvailableSound(path)
        local largest = 0
        local largest_snd = available_instruments[path][1]
    
        for i=1, #available_instruments[path] do
            local snd = available_instruments[path][i]
            local status = instrument_status[snd]
            
            if status.isPlaying == false then
                return snd
            elseif status.isPlaying and timer.realtime() > status.finishPlaying then
                snd:pause()
                if not status.isLooped then snd:setTime(0) end
                return snd
            end
            
            if largest < status.finishPlaying then
                largest = status.finishPlaying
                largest_snd = snd
            end
        end
        
        return largest_snd
    end
    
    local function getSoundByKey(path,key)
        for i=1, #available_instruments[path] do
            local snd = available_instruments[path][i]
            local status = instrument_status[snd]
            
            if status.key == key then return snd end
        end
    end
    
    local function getPathFromChannel( channel )
        return sound_channels[channel]
    end
    
    local loading = 0
    local proceed
    print("LOADING SOUND CHANNELS")
    for instrument, _ in pairs( parsed.instruments ) do
        print("Loading",instrument)
        for i=1,num_per_channel do
            loading = loading + 1
            wait = wait + 0.1
            timer.simple(wait,function()
                bass.loadFile( instrument, "noplay noblock", function(snd,err,b)
                    if err ~= 0 then
                        print("unable to load sound",instrument,err,b)
                    else
                        addAvailableSound(instrument,snd)
                    end
                    
                    loading = loading - 1
                    if loading == 0 then
                        print("DONE LOADING!")
                        proceed() 
                    end
                end )
            end)
        end
    end
    
    local function createSound( channel, path )
        if parsed.instruments[path] then
            sound_channels[channel] = path
            --print("channel",channel,"set to",path)
        end
    end
    
    local key_to_freq = {
        [88]=4186.009,[87]=3951.066,[86]=3729.31,
        [85]=3520,[84]=3322.438,[83]=3135.963,
        [82]=2959.955,[81]=2793.826,[80]=2637.02,
        [79]=2489.016,[78]=2349.318,[77]=2217.461,
        [76]=2093.005,[75]=1975.533,[74]=1864.655,
        [73]=1760,[72]=1661.219,[71]=1567.982,
        [70]=1479.978,[69]=1396.913,[68]=1318.51,
        [67]=1244.508,[66]=1174.659,[65]=1108.731,
        [64]=1046.502,[63]=987.7666,[62]=932.3275,
        [61]=880,[60]=830.6094,[59]=783.9909,
        [58]=739.9888,[57]=698.4565,[56]=659.2551,
        [55]=622.254,[54]=587.3295,[53]=554.3653,
        [52]=523.2511,[51]=493.8833,[50]=466.1638,
        [49]=440,[48]=415.3047,[47]=391.9954,
        [46]=369.9944,[45]=349.2282,[44]=329.6276,
        [43]=311.127,[42]=293.6648,[41]=277.1826,
        [40]=261.6256,[39]=246.9417,[38]=233.0819,
        [37]=220,[36]=207.6523,[35]=195.9977,
        [34]=184.9972,[33]=174.6141,[32]=164.8138,
        [31]=155.5635,[30]=146.8324,[29]=138.5913,
        [28]=130.8128,[27]=123.4708,[26]=116.5409,
        [25]=110,[24]=103.8262,[23]=97.99886,
        [22]=92.49861,[21]=87.30706,[20]=82.40689,
        [19]=77.78175,[18]=73.41619,[17]=69.29566,
        [16]=65.40639,[15]=61.73541,[14]=58.27047,
        [13]=55,[12]=51.91309,[11]=48.99943,
        [10]=46.2493,[9]=43.65353,[8]=41.20344,
        [7]=38.89087,[6]=36.7081,[5]=34.64783,
        [4]=32.7032,[3]=30.86771,[2]=29.13524,
        [1]=27.5
    }
    
    local function playSound( channel, key, velocity )
        local path = getPathFromChannel(channel)
        if not path then return end
        --if not path then error("MIDI tried to use nonexistant sound channel '"..channel.."'") end
        
        local basefreq = 880
        if string.find(path,"piano") == nil then basefreq = 880 end
            
        local freq = key_to_freq[key] or basefreq
        local pitchmult = freq / basefreq -- this will do for now, may fix later
        
        local volume = velocity / 64
        
        local sound = getAvailableSound(path)
        sound:setPos(chip():getPos())
        sound:setPitch(pitchmult + (channel_pitches[channel] or 0))
        sound:setVolume(volume)
        sound:play()
        
        local status = instrument_status[sound]
        status.finishPlaying = timer.realtime() + status.soundDuration * (1/pitchmult) + 0.05
        status.isPlaying = true
        status.key = key
    end
    
    local function stopSound( channel, key )
        local path = getPathFromChannel(channel)
        if not path then return end
        --if not path then error("MIDI tried to use nonexistant sound channel '"..channel.."'") end
        
        local sound = getSoundByKey(path,key)
        if sound then
            local status = instrument_status[sound]
            status.finishPlaying = 0
            status.isPlaying = false
            status.key = false
            
            sound:pause()
            if not sound.isLooped then 
                sound:setTime(0)
            end
        end
    end
    
    local events = {
        ["note on"] = function(event)
            local channel = event.channel
            local key = event.param1
            local velocity = event.param2
            
            if velocity == 0 then
                stopSound( channel, key )
            else
                playSound( channel, key, velocity )
            end
        end,
        ["note off"]= function(event)
            local channel = event.channel
            local key = event.param1
            --local velocity = event.param2
            
            stopSound( channel, key )
        end,
        ["polyphonic pressure"] = function(event)
            -- not used for now
        end,
        ["control change"] = function(event)
            -- not used for now
        end,
        ["program change"] = function(event)
            local channel = event.channel
            local instrument = event.instrument
            createSound( channel, instrument )
        end,
        ["channel pressure"] = function(event)
            -- not used for now
        end,
        ["pitch blend"] = function(event)
            --print("PITCH BLEND",event.param1/0x0040)
            channel_pitches[event.channel] = event.param1 / 0x0040
        end,
        ["tempo"] = function(event)
            parsed.ms = event.new_ms
            --print("setting tempo, ms: "..parsed.ms..", tempo: "..event.param1..", ppqn: "..parsed.ppqn)
        end,
        ["end of track"] = function(event)
            -- nothing for now
        end
    }
    
    proceed = function()
        timer.simple(0.5,function()
            local nextEvents = {}
            hook.add("think","playthink",function()
                for i=#nextEvents,1,-1 do
                    local event = nextEvents[i]
                    if timer.realtime() >= event.processAt then
                        event.callback()
                        table.remove(nextEvents,i)
                    end
                end
            end)
            local function playTrack(track,callback)
                local index = 1
                local function doEvent()
                    while true do
                        local event = track[index]
                        if not event or event.command == "end of track" then
                            if callback then callback() end
                            return
                        end
                        
                        if event.deltatime == 0 then
                            --print("doing event",event.command,event.channel)
                            if events[event.command] then
                                events[event.command]( event )
                            else
                                error("Unknown MIDI command specified '"..event.command.."'")
                            end
                            
                            index = index + 1
                        else
                            nextEvents[#nextEvents+1] = {
                                processAt = timer.realtime() + parsed.ms * event.deltatime / 1000,
                                callback = doEvent
                            }
                            event.deltatime = 0
                            return
                        end
                    end
                end
                
                doEvent()
            end
            
            if format == 0 then -- only one track
                print("format is 0, playing 1st track")
                playTrack(parsed.tracks[1],function()
                    print("DONE PLAYING!")
                    hook.remove("think","playthink")
                end)    
            elseif format == 1 then -- several tracks, and first tracks contains all tempos
                print("format is 1, playing all tracks simultaneously")
                local played = 0
                for i=1,#parsed.tracks do
                    --if i==9 then continue end
                    played = played + 1
                    playTrack(parsed.tracks[i],function()
                        played = played - 1
                        if played == 0 then
                            print("DONE PLAYING!")
                            hook.remove("think","playthink")
                        end
                    end)
                end
            elseif format == 2 then -- several tracks, played one at a time
                --print("format is 2, playing all tracks one by one")
                local current_track = 0
                local function playNext()
                    current_track = current_track + 1
                    if parsed.tracks[current_track] then
                        --print("Track '"..current_track.."' done, playing next track in 4 seconds...")
                        playTrack(parsed.tracks[current_track],function()
                            timer.simple(4,playNext)
                        end)
                    else
                        print("DONE PLAYING!")
                        hook.remove("think","playthink")
                    end
                end
                playNext()
            end
        end)
    end
end

http.get(download,function(str)
    doParse(str,playMIDI)
end,function(a,b,c) print(a,b,c) end)
